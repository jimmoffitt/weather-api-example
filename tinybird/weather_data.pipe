DESCRIPTION >
	A Tinybird 'Pipe' that operates on the incoming_weather_data Data Source. Here we apply the 'start_time' and 'end_times' query parameters, then apply any 'sensor_type' query parameter, and finally apply the 'max_results' query parameter. This demo is driven by polling data from OpenWeatherMap and loading that into Tinybird with the Events API.


NODE city_and_period_of_interest
DESCRIPTION >
    Applying 'city', 'start_time', and 'end_time' query parameters. A case where we pull in every field and do not take this opportunity to drop fields. The fields arriving via the Event API have already been curated by a Python script.

SQL >

    %
    SELECT *
    FROM incoming_weather_data
    WHERE
        1=1
         {% if defined(city) %}
            AND lowerUTF8(site_name) LIKE lowerUTF8({{ String(city, description="Name of US City to retrieve data for.") }})
         {% end %}
         {% if defined(start_time) and defined(end_time) %}
             AND (toDateTime(timestamp) BETWEEN {{DateTime(start_time, description="Start date in format YYYY-MM-DD HH:MM:SS. Defaults to one week ago if not defined.")}}
             AND {{DateTime(end_time, description="End date in format YYYY-MM-DD HH:MM:00. Defaults to NOW if not defined.")}})
         {% end %}
         {% if not defined(start_time) and not defined(end_time) %}
            AND toDateTime(timestamp) BETWEEN addDays(now(),-7) AND now()
         {% end %}
         {% if defined(start_time) and not defined(end_time) %}
             AND toDateTime(timestamp) BETWEEN {{DateTime(start_time, description="Start date in format YYYY-MM-DD. Defaults to yesterday if not defined.")}}
             AND now()
         {% end %}
     


NODE sensor_type
DESCRIPTION >
    Here we support the sensor_type query parameters. When used, just that data type is returned.

SQL >

    %
    SELECT
        timestamp,
        site_name,
        {% if defined(sensor_type) %}
            {% if String(sensor_type, description="Type of weather data to return. Options: temp, precip, wind, humidity, pressure, and clouds. ") == 'temp' %} temp_f
            {% elif sensor_type == 'precip' %} precip
            {% elif sensor_type == 'wind' %} wind_speed, wind_dir
            {% elif sensor_type == 'humidity' %} humidity
            {% elif sensor_type == 'pressure' %} pressure
            {% elif sensor_type == 'clouds' %} clouds
            {% end %}
        {% else %}
            temp_f,
            precip,
            wind_speed,
            wind_dir,
            humidity,
            pressure,
            clouds,
            description
        {% end %} 
    FROM city_and_period_of_interest



NODE endpoint
DESCRIPTION >
    Here we apply the 'max_results' parameter, and if a sensor_type parameter is included, we order by descending values of that sensor type. So, sensor_type=temp&limit=10 will return the top highest temperatures for the period of interest.

SQL >

    %

    SELECT * FROM sensor_type
    {% if defined(sensor_type) and defined(max_results) %}
        {% if sensor_type == 'temp' %} 
          ORDER BY temp_f DESC
        {% elif sensor_type == 'precip' %} 
          ORDER BY precip DESC
        {% elif sensor_type == 'wind' %} 
          ORDER BY wind_speed DESC
        {% elif sensor_type == 'humidity' %} 
          ORDER BY humidity DESC	
        {% elif sensor_type == 'pressure' %} 
          ORDER BY pressure DESC
        {% elif sensor_type == 'clouds' %} 
          ORDER BY clouds DESC
        {% end %}
    {% else %}
      ORDER BY timestamp DESC
    {% end %} 
    {% if defined(max_results) %}
    LIMIT {{Int16(max_results, description="The maximum number of weather data points to return.")}}
    {% end %}

